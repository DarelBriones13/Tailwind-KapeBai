const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
import { EventEmitter } from 'events';
import Stream from 'stream';
import { StringDecoder } from 'string_decoder';
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export class Minipass extends EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTAòAO]èòUøt	HMèè8ëÿ3ÀL\$`I‹s0I‹{8I‹ãA_A^]ÃÌÌÌÌÌÌÌÌÌÌÆAxÃÌÌÌÌÌÌÌÌÌÌÌHAÃÌÌÌÌÌÌÌÌÌÌÌHA ÃÌÌÌÌÌÌÌÌÌÌÌHA8ÃÌÌÌÌÌÌÌÌÌÌÌHAPÃÌÌÌÌÌÌÌ@USVWATAVAWH‹ìHƒì@I‹ùM‹àH‹ÚL‹ñM…ÀtTI‹ÈèYrëÿ„ÀuHHÍ ÇEğ  H‰EàH\Í H‰EèHÉÍ A¸  ÀH‰EøHøÔ HMàè§Jëÿ¸  Àé-  H…Ût2H‹Ëè rëÿ„Àu&HÅÌ ÇEğ  H‰EàHÍ H‰EèH°Í ë¥H…ÿt5H‹ÏèÉqëÿ„Àu)HÌ ÇEğ  H‰EàHÌÌ H‰EèH±Í ékÿÿÿIvHƒ~ tH‹Îè™6ëÿWÀ3ÀH‰EğòEğòFM~ Iƒ t I‹Ïèp6ëÿWÀ3ÀAH‰EğòEğòAGIƒ~H t"IN8èH6ëÿWÀ3ÀAF8H‰EğòEğòAFHH…ÿtIV8H‹Ïèfëÿ…Àx*M…ätH‹ÖI‹Ìè
fëÿ…ÀxH…ÛtI‹×H‹Ëèöeëÿ…Àx3ÀHƒÄ@A_A^A\_^[]ÃÌÌÌÌÌÌÌÌÌH‰\$WHƒì@H‹ÚH‹ùH…ÒtVH‹Êè«pëÿ„ÀuJHpË ÇD$0«  H‰D$ HdÓ HÍË A¸  ÀH‰D$(HL$ HÖË H‰D$8èôHëÿ¸  Àë@Hƒ` t"HOPè]5ëÿWÀ3ÀGPH‰D$0òD$0òG`H…ÛtHWPH‹Ëè3eëÿ…Àx3ÀH‹\$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì@H‹ÚH‹ùH…ÒtVH‹Êèãoëÿ„ÀuJH¨Ê ÇD$0¿  H‰D$ HœÒ H-Ì A¸  ÀH‰D$(HL$ H¶Ë H‰D$8è,Hëÿ¸  Àë@HƒH t"HO8è•4ëÿWÀ3ÀG8H‰D$0òD$0òGHH…ÛtHW8H‹Ëèkdëÿ…Àx3ÀH‹\$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì@H‹ÚH‹ùH…ÒtVH‹Êè#oëÿ„ÀuJHèÉ ÇD$0Ë  H‰D$ HÜÑ HË A¸  ÀH‰D$(HL$ H–Ë H‰D$8èlGëÿ¸  Àë@Hƒ t"HOèÕ3ëÿWÀ3ÀGH‰D$0òD$0òGH…ÛtHWH‹Ëè«cëÿ…Àx3ÀH‹\$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì@H‹ÚH‹ùH…ÒtVH‹Êècnëÿ„ÀuJH(É ÇD$0×  H‰D$ HÑ H…Ê A¸  ÀH‰D$(HL$ HÖÊ H‰D$8è¬Fëÿ¸  Àë@Hƒ0 t"HO è3ëÿWÀ3ÀG H‰D$0òD$0òG0H…ÛtHW H‹Ëèëbëÿ…Àx3ÀH‹\$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì@HYPH‹úHƒ{ t H‹Ëè°2ëÿWÀ3ÀH‰D$0òD$0òCH…ÿtH‹ÓH‹Ïèˆbëÿ…Àx3ÀH‹\$`HƒÄ@_ÃÌÌÌÌÌÌÌ¸$  ÀÃÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì H‹A‹ØH‹úƒËH‹@ ÿ0ª D‹ÃH‹×H‹ÈH‹\$0HƒÄ _é|÷ÿÿÌÌÌÌÌÌÌÌH‰\$H‰|$UHl$©Hì   H‹ª0 H3ÄH‰EOD‰ˆ   HE7H‰EÿLMÿH‹ùH‰Qp¹   ÇE÷	   H‰MHE÷H‰ELEH‹GhHU'‡€   H‰MH‹óE'H‹H‹@hÿ© 3Û…ÀxH‹U?H‹Ïè³ûÿÿ…ÀHØ‹ÃH‹MOH3Ìè¾ Lœ$   I‹[I‹{ I‹ã]ÃÌÌÌÌÌÌÌH‰\$WHƒì@Hƒy` H‹Ùt"HƒÁPè?1ëÿWÀ3ÀCPH‰D$0òD$0òC`Hƒ{H t"HK8è1ëÿWÀ3ÀC8H‰D$0òD$0òCHHƒ{0 t"HK èí0ëÿWÀ3ÀC H‰D$0òD$0òC0Hƒ{ t"HKèÄ0ëÿWÀ3ÀCH‰D$0òD$0òCH‹\$PHƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰|$UHl$©Hì   H‹/ H3ÄH‰EOD‰ˆ   HE7H‰EÿLMÿH‹ùH‰Qp¹   ÇE÷	   H‰MHE÷H‰ELEH‹GhHU'‡€   H‰MH‹óE'H‹H‹@`ÿı§ 3Û…ÀxH‹U?H‹Ïè#úÿÿ…ÀHØ‹ÃH‹MOH3Ìèˆ¼ Lœ$   I‹[I‹{ I‹ã]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@USWHl$¹HìĞ   H‹Q. H3ÄH‰E73ÀA‹ØH‰E×WÀH‹H‹úEÇƒËH‹@ ÿo§ D‹ÃHUÇH‹ÈèÄôÿÿ‹Ø…Àxu³• LM¯3Àòµ• LEç)EçEÇPH‰E¿òM÷òM×Eÿe• òMòh• )EWÀE¯òM'ècëÿ‹Ø…Ày$Hƒ}¿ t	HM¯èõ.ëÿHƒ}× t	HMÇèå.ëÿ‹ÃëIòWE¯òM¿òU§Hƒ}§ òO]¯òU¿t	HM¯èª.ëÿHƒ}× t	HMÇèš.ëÿ3ÀH‹M7H3Ìè,» HÄĞ   _[]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰|$UHl$©Hìà   H‹ú, H3ÄH‰EGH‹AhLM§fo; H‹ùD‰    LE·H‰Qpº   óE×˜   H‹HEçH‰E§HE×H‰E·H‰U¯H‰U¿HUÇH‹óEÇH‹€ˆ   ÿÔ¥ 3Û…Àx+L‹MH‹ÏL‹EH‹Uïè6öÿÿ…ÀxH‹U7H‹Ïèâ÷ÿÿ…ÀHØ‹ÃH‹MGH3ÌèGº Lœ$à   I‹[I‹{ I‹ã]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$ UVWAVAWHl$ğHì  H‹	, H3ÄH‰E 3ÀLt$pH‰D$`WÀH‹WÉE3ÿA‹ØH‹òL‰|$HH‹ùH‹@ D$PL$8ÿ¥ D‹ÃHT$PH‹Èèdòÿÿ‹Ø…Àˆ  H‹H‹ÏH‹@ÿæ¤ L98t>H‹H‹ÏH‹@ÿÑ¤ Lu  )D$pòHÙ“ òM€òÜ“ òM˜EˆH‹H‹ÏH‹@ÿ“¤ LL$8LD$p AòHHD$py“ òANò{“ AFD$PòAN(òL$`AF0Ñ’ òAN@IƒÆHòÏ’ AòANL+ğIƒÆH¸«ªªªªªª*I÷îHÁúH‹ÂHÁè?HĞè
`ëÿ‹Ø…Ày*L‹|$HM…ÿt
HL$8èô+ëÿHƒ|$` t
HL$Pèâ+ëÿ‹ÃëPòVD$8òL$HòT$0òN\$8òT$HL9|$0t
HL$8è¡+ëÿL9|$`t
HL$Pè+ëÿ3ÀH‹M H3Ìè"¸ H‹œ$X  HÄ  A_A^_^]ÃÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰X UVWATAUAVAWH¨¸şÿÿHì  )p¸)x¨H‹Ù) H3ÄH‰…à   3ÀD‰D$ WÀH‰E H‰D$XH]ĞH‰D$pWöH‰E°WÿH‰EÈE3äH‹L‹êH‰U¨H‹ñEL‰d$8H‹@t$H|$`óD$(E¸ÿ¶¢ L9 t=H‹H‹ÎH‹@ÿ¡¢ H]  )EĞòHª‘ òMàò­‘ òMøEèH‹H‹ÎH‹@ÿd¢ I¿«ªªªªªª*LMLEĞ òHHEĞòKH+ØHƒÃI‹ÇH÷ëHÁúH‹ÂHÁè?HĞè*^ëÿ…ÀA‹üHø…ÿˆ~  ‹†°   …À„  D‹ÀHT$@HL$(M‹üè#  ‹8…ÿˆQ  E‹ôH‹\$(D9¦°   tRH‹†¸   A‹ÖH‹ĞH‹I8D8axu.D‹D$ HRL$ÃH‹I‹ÔH‹@(ÿ›¡ ‹ø…Àˆ  M<$E3äAÿÆD;¶°   u®HT$`I‹ÏèÕ(ëÿ‹ø…ÀˆÜ   E‹üD9¦°   tiH‹†¸   A‹×H‹ĞH‹A8D8`xuEHRL4ÃI‹ÎHT$`è_ëÿ‹ø…Àˆ™   M9ft I‹Îè&)ëÿWÀ3ÀAH‰EˆòEˆòAFAÿÇD;¾°   u—|$`I¿«ªªªªªª*ëH‹\$(D‹”   L‹t$0E…É„i  I‹ÎI‹ÇH+ËE‹ÁH÷éHÁúH‹ÂHÁè?HĞL;Êv<HT$@HL$(èÎ  ‹8…ÿyH‹\$(L‹t$0H‹E°E3äéŞ  D‹”   L‹t$0H‹\$(E3ÿE…ÉtOH‹†˜   J‹øH‹I8€yx u*D‹D$ KL,ÃH‹I‹ÕH‹@(ÿ/  ‹ø…Àx£IÿÄMe AÿÇD;¾”   uµL‹m¨HT$HI‹Ìèi'ëÿ‹ø…ÀˆuÿÿÿE3äD9¦”   „…   H‹†˜   J‹àH‹A8€xx uaKdHT$HH> L<Ãè¥]ëÿ‹ø…Àˆ-ÿÿÿHT$HI‹Ïè]ëÿ‹ø…ÀˆÿÿÿIƒ t I‹Ïè'ëÿWÀ3ÀAH‰EˆòEˆòAGAÿÄD;¦”   éuÿÿÿt$HE3äÿ LM¸º   òş LE m‡ òe òŠ )E òD$XòE`òD$pòM0A ò…   òA ò…¨   m8òeH)uP]hòUx)½€   ˜   )­°   ò¥À   È   ò•Ø   è¶Zëÿ‹ø…À‰‘   H‹EÈH…Àt	HM¸è&ëÿI;Şt5IvèL9ftH‹Îè‡&ëÿWÀ3ÀH‰EˆòEˆòFHƒîHFH;ÃuÏH…ÛtH‹ËèÇÃ L9d$pt
HL$`èF&ëÿL9d$Xt
HL$Hè5&ëÿL9e t	HMè&&ëÿ‹Çé¶   òAUA] E¸òMÈòUˆAE òAM]¸òUÈL9eˆt	HM¸èã%ëÿI;Şt5I~èL9gtH‹ÏèÌ%ëÿWÀ3ÀH‰EˆòEˆòGHƒïHGH;ÃuÏH…ÛtH‹ËèÃ L9d$pt
HL$`è‹%ëÿL9d$Xt
HL$Hèz%ëÿL9e t	HMèk%ëÿ3ÀH‹à   H3Ìèú± Lœ$  I‹[XA(sğA({àI‹ãA_A^A]A\_^]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$UWAVHl$¹Hì°   H‹§# H3ÄH‰E?H‹AhLMßD‰ˆ   H‹Ù€   H‰QpLE÷HM×H‰L$ HUÇH‹óEÇèù»  …ÀˆÑ  L‹M×H‹ËL‹EßH‹U÷èíÿÿ…Àˆµ  H‹ChLM÷ƒ€   ÇE    LEßÇE   º   H‹HEH‰E÷HEH‰EßH‰UÿH‰UçHUÇH‹óEÇH‹€   ÿ/œ …ÀˆS  H‹ChH³”   EL‹ÆHUÇH‹óEÇH‹H‹€È   ÿù› …Àˆ  H‹E/H‹H¸ÿÿÿÿH;È‡  ‹Á‰ƒ°   H;Èt
¸å  Àéğ   D‹L³˜   I‹ÎHU×è2  ‹ …ÀˆĞ   3ÿ9>t]H‹ChLM÷ED‹ÇHUÇH‹óEÇH‹H‹€À   ÿs› …Àˆ—   I‹HUÇ(E÷L‹ÃH‹KhfEÇLøèK
  …ÀxsÿÇ;>u£D‹ƒ°   H³¸   H‹ÎHU×è«  ‹ …ÀxM3ÿ9»°   t:H‹E/L‹Ã‹×HÒH‹H‹ÑH‹KhLøHUÇóEÇèë	  …ÀxÿÇ;»°   uÆ3Àë¸•  ÀH‹M?H3Ìèx¯ Lœ$°   I‹[(I‹s0I‹ãA^_]ÃÌÌÌÌÌÌÌÌH‰\$UVWHƒì 3ÿH‹êH‹ÙH9z tE‹±”   H‹‘˜   …öt+HúH9)tÿÇ;şuñëD‹ÆHQD+ÇAÿÈIÁàèFÉ ;şuÌÿ‹”   ëC‹±°   H‹‘¸   …öt+HúH9)tÿÇ;şuñëD‹ÆHQD+ÇAÿÈIÁàèÉ ;şuÌÿ‹°   H‹M8H‹H‹ÿö™ H‹M8H‹\$PHƒap 3ÀHƒÄ _^]ÃÌÌÌÌÌÌÌÌÌÌH‰\$ UVWHƒì0Hƒz  H‹òA‹èH‹ùtS‹—”   HÁ˜   L‹H‹AI+ÀHÁøH;Ğu%DBHT$ è  ‹ …Àˆ¤   ‹—”   L‹‡˜   ‹ÂI‰4Àÿ‡”   ëwH™¸   ‹‰°   H‹CH+HÁøH;ÈuDAH‹ËHT$ è»  ‹ …ÀxUƒıÿt+‹—°   …Òt!H‹+ÕD‹ÂIÁàHéHKH‹ÓèöÇ H‰3ë‹°   H‹H‰4Èÿ‡°   H‹F8Æ@x H‹F8H‰xp3ÀH‹\$hHƒÄ0_^]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$UVWAVAWHƒìP‹±°   3ÛL‹úH‹ù‹Ó…ötL‹¸   ‹ÂI‹ÀH9Y„   ÿÂ;Öuê‹ë…öt$L‹óH‹—¸   H‹ÏI‹è»ıÿÿ…ÀxRÿÅIƒÆ;îrß‹Ã…ÀxBH‹OhHT$ H‰\$ èŒ  …Àx+H‹t$ I‹×H‹N8è_êÿÿ…ÀxAƒÈÿH‹ÖH‹Ïè@şÿÿ…ÀHØ‹ÃH‹œ$   HƒÄPA_A^_^]ÃÌHÁµ ÇD$8_  H‰D$(Hµ½ HÎ· A¸  ÀH‰D$0HL$(Hß· H‰D$@èE3ëÿ¸  Àë¡ÌÌÌÌÌÌH‰\$H‰|$ UHl$©HìĞ   H‹B H3ÄH‰EGL‹ÊH‹ùH…ÒuHHAµ ÇEÇ…  H‰E·H7½ H˜· A¸  ÀH‰E¿HM·H«· H‰EÏèÊ2ëÿ¸  Àé„  H‹LEHƒe Hu½ I‹ÉH‹@ÿ— ‹Ø…ÀxH‹MH…Éu»¹ Àë)H‹H‰ëH‹UH…ÒtHƒe H‹ÊH‹H‹ ÿÕ– …Ûy‹Ãé  H‹HU'Hƒe Hƒe H‹H‹@ÿ¬– ‹Ø…Àˆ   H‹LE7(E'HU×fE×H‹H‹@ÿ– ‹Ø…ÀxhH‹LE(E'HUçfEçH‹H‹€@  ÿW– ‹Ø…Àx>L‹EHO(HU§èÄ  ‹…Ûx'(E7LM¯Hƒe¯ HU÷E3ÀfE÷H‹Ïè  ‹Ø…Ày7L‹EM…À„5ÿÿÿHƒe 3ÒHƒe eH‹%`   H‹I0Hÿö’ D  éÿÿÿL‹EM…Àt%Hƒe 3ÒHƒe eH‹%`   H‹I0HÿÃ’ D  3ÀH‹MGH3ÌèPª Lœ$Ğ   I‹[ I‹{(I‹ã]ÃÌÌÌÌÌÌÌH‰\$H‰l$ VWAVHƒì 3íH‹ñL‹òH‰*M@ès° ¹   H‹ØH‰hH‰(H‰hH‰hH‰h H‰h(H‰h0èK° 3ÒDE`H‹øHHèuÁ H‰ohH²Y H‰H‰opf‰oxƒˆ   ÿH9k0tÌH‰{0HVH‰op‹ÅH‹l$XH‰whH‰{8I‰H‹JH‰KH‰H‹JH‰H‰ZH‰SHÿBH‹\$PHƒÄ A^_^ÃÌÌÌÌÌÌÌH‰\$H‰l$ VWAVHƒì 3íH‹ñL‹òH‰*M@èŸ¯ ¹   H‹ØH‰hH‰(H‰hH‰hH‰h H‰h(H‰h0èw¯ 3ÒDE`H‹øHHè¡À H‰ohHY H‰H‰opf‰oxƒˆ   ÿH9ktÌH‰{HVH‰op‹ÅH‹l$XH‰whH‰{8I‰H‹JH‰KH‰H‹JH‰H‰ZH‰SHÿBH‹\$PHƒÄ A^_^ÃÌÌÌÌÌÌÌH‰\$H‰l$ VWAVHƒì 3íH‹ñL‹òH‰*M@èË® ¹Ğ   H‹ØH‰hH‰(H‰hH‰hH‰h H‰h(H‰h0è£® 3ÒDE`H‹øHHèÍ¿ H‰ohH²W H‰H‰opf‰oxƒˆ   ÿ@ˆ¯   ‰¯”   H‰¯˜   H‰¯    H‰¯¨   ‰¯°   H‰¯¸   H‰¯À   H‰¯È   H9k(tÌH‰{(HVH‰op‹ÅH‹l$XH‰whH‰{8I‰H‹JH‰KH‰H‹JH‰H‰ZH‰SHÿBH‹\$PHƒÄ A^_^ÃÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$ VWAVHƒì 3íH‹ñL‹òH‰*M@è·­ ¹¨   H‹ØH‰hH‰(H‰hH‰hH‰h H‰h(H‰h0è­ 3ÒDE`H‹øHHè¹¾ H‰ohHNW H‰H‰opf‰oxH‰¯   H‰¯€   H‰¯ˆ   ƒ    ÿH9k tÌH‰{ HVH‰op‹ÅH‹l$XH‰whH‰{8I‰H‹JH‰KH‰H‹JH‰H‰ZH‰SHÿBH‹\$PHƒÄ A^_^ÃÌÌÌÌÌÌÌÌÌÌL‹ÜI‰[I‰s WHƒìpH‹} H3ÄH‰D$`H‹ùH‹òH‹	ISÈ3ÛI‰[¨H‹H‹@ÿ‘ …ÀxpH‹LD$P(D$@HT$0fD$0H‹H‹@ÿt‘ …ÀxG(D$PLL$ E3ÀfD$0HT$0H‹ÏèP   …Àx#H‹L$ H‹ÖH‹I8L‹I‹@(E3Àÿ0‘ …ÀHØ‹ÃH‹L$`H3ÌèÌ¥ L\$pI‹[ I‹s(I‹ã_ÃÌÌÌÌÌÌÌÌÌÌ@USVWAVAWHl$ÑHì¸   H‹œ H3ÄH‰EIƒ! H‹ÙH‹I(I‹ñD‹rM‹øH‹C0H+ÁHÁøL;ğrHH® ÇE=  H‰E÷HM÷H± H‰EÿHp± H‰EH]¶ A¸  Àè
,ëÿ¸  ÀéR  Jƒ<ñ …>  (HE÷H‰E×LM×¹   ÇE§   H‰MßHE§H‰MïLEçH‹HU·H‰EçfE·H‹H‹€˜   ÿ …Àˆô   ·     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}
//# sourceMappingURL=index.js.map